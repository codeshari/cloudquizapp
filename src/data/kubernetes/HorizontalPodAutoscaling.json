[
    {
      "question": "In a Kubernetes HorizontalPodAutoscaler, what metric is used to scale based on the observed application throughput?",
      "answers": [
        { "text": "CPU utilization", "isCorrect": false },
        { "text": "Memory consumption", "isCorrect": false },
        { "text": "Requests per second (RPS)", "isCorrect": true },
        { "text": "Network bandwidth", "isCorrect": false }
      ]
    },
    {
      "question": "You have a Kubernetes application with variable traffic patterns. What HorizontalPodAutoscaler policy would be most suitable?",
      "answers": [
        { "text": "Stable traffic mode", "isCorrect": false },
        { "text": "Predictive scaling", "isCorrect": true },
        { "text": "Static scaling", "isCorrect": false },
        { "text": "Manual scaling", "isCorrect": false }
      ]
    },
    {
      "question": "When using HorizontalPodAutoscaler, what is the significance of the target value for CPU utilization set to 80%?",
      "answers": [
        { "text": "Scale in when CPU usage is above 80%", "isCorrect": false },
        { "text": "Scale out when CPU usage is below 80%", "isCorrect": false },
        { "text": "Maintain CPU usage close to 80%", "isCorrect": true },
        { "text": "Ignore CPU usage and scale based on memory", "isCorrect": false }
      ]
    },
    {
      "question": "Your application has occasional bursts of traffic. Which HorizontalPodAutoscaler setting is crucial for handling sudden load spikes?",
      "answers": [
        { "text": "Cooldown period", "isCorrect": false },
        { "text": "Target average value", "isCorrect": false },
        { "text": "Target utilization threshold", "isCorrect": true },
        { "text": "Min replicas", "isCorrect": false }
      ]
    },
    {
      "question": "What impact does setting a longer cooldown period have on the HorizontalPodAutoscaler?",
      "answers": [
        { "text": "Increases responsiveness to load changes", "isCorrect": false },
        { "text": "Decreases the time between scale-out events", "isCorrect": false },
        { "text": "Reduces the frequency of scale changes", "isCorrect": true },
        { "text": "Improves overall system performance", "isCorrect": false }
      ]
    },
    {
      "question": "You have a Kubernetes application with varying traffic patterns between weekdays and weekends. What strategy could be effective for HorizontalPodAutoscaler?",
      "answers": [
        { "text": "Use a fixed schedule for scaling", "isCorrect": false },
        { "text": "Implement predictive scaling based on historical data", "isCorrect": true },
        { "text": "Manually adjust replicas on weekdays", "isCorrect": false },
        { "text": "Scale based on memory consumption", "isCorrect": false }
      ]
    },
    {
      "question": "When using HorizontalPodAutoscaler, what role does the `targetAverageValue` play for custom metrics?",
      "answers": [
        { "text": "Represents the target CPU utilization", "isCorrect": false },
        { "text": "Defines the average memory usage target", "isCorrect": false },
        { "text": "Specifies the desired metric value", "isCorrect": true },
        { "text": "Indicates the target network bandwidth", "isCorrect": false }
      ]
    },
    {
      "question": "In a scenario with rapid traffic fluctuations, which metric would be more suitable for HorizontalPodAutoscaler: CPU or Memory?",
      "answers": [
        { "text": "CPU", "isCorrect": false },
        { "text": "Memory", "isCorrect": false },
        { "text": "Both CPU and Memory", "isCorrect": true },
        { "text": "Neither, use a fixed number of replicas", "isCorrect": false }
      ]
    },
    {
      "question": "Your application's response time is critical. Which HorizontalPodAutoscaler metric should be prioritized?",
      "answers": [
        { "text": "CPU utilization", "isCorrect": false },
        { "text": "Memory consumption", "isCorrect": false },
        { "text": "Latency or response time", "isCorrect": true },
        { "text": "Network bandwidth", "isCorrect": false }
      ]
    },
    {
      "question": "You have a Kubernetes application that experiences load changes every hour. What HorizontalPodAutoscaler parameter should be adjusted to accommodate this pattern?",
      "answers": [
        { "text": "Cooldown period", "isCorrect": false },
        { "text": "Target average value", "isCorrect": false },
        { "text": "Target utilization threshold", "isCorrect": false },
        { "text": "Periodic scaling frequency", "isCorrect": true }
      ]
    },
    {
        "question": "In Kubernetes HorizontalPodAutoscaler, what is the role of the `minReplicas` parameter?",
        "answers": [
          { "text": "Specifies the minimum CPU utilization threshold", "isCorrect": false },
          { "text": "Defines the minimum number of replicas to be maintained", "isCorrect": true },
          { "text": "Sets the minimum memory consumption target", "isCorrect": false },
          { "text": "Indicates the minimum network bandwidth requirement", "isCorrect": false }
        ]
      },
      {
        "question": "Your application has varying traffic during business hours and low traffic at night. Which metric is most suitable for HorizontalPodAutoscaler to scale based on this pattern?",
        "answers": [
          { "text": "CPU usage", "isCorrect": false },
          { "text": "Memory consumption", "isCorrect": false },
          { "text": "Network bandwidth", "isCorrect": false },
          { "text": "Custom metric representing business activity", "isCorrect": true }
        ]
      },
      {
        "question": "What is the purpose of the `scaleDownUtilizationThreshold` in Kubernetes HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Defines the utilization threshold for scaling down", "isCorrect": false },
          { "text": "Specifies the minimum replicas before scaling down", "isCorrect": false },
          { "text": "Sets the cooldown period for scaling down", "isCorrect": false },
          { "text": "Ensures stability by avoiding rapid scale-downs", "isCorrect": true }
        ]
      },
      {
        "question": "In a scenario where the CPU utilization is consistently high, what impact does increasing the `targetAverageValue` have on HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Increases responsiveness to load changes", "isCorrect": true },
          { "text": "Decreases the time between scale-out events", "isCorrect": false },
          { "text": "Reduces the frequency of scale changes", "isCorrect": false },
          { "text": "Improves overall system performance", "isCorrect": false }
        ]
      },
      {
        "question": "When considering custom metrics for HorizontalPodAutoscaler, what factor should be prioritized for effective autoscaling?",
        "answers": [
          { "text": "Metrics with the highest range", "isCorrect": false },
          { "text": "Metrics directly correlated with user activity", "isCorrect": true },
          { "text": "Metrics with the lowest variability", "isCorrect": false },
          { "text": "Metrics related to system health", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application is sensitive to memory fluctuations. Which HorizontalPodAutoscaler setting should be adjusted?",
        "answers": [
          { "text": "Target utilization threshold for CPU", "isCorrect": false },
          { "text": "Cooldown period", "isCorrect": false },
          { "text": "Target average value for memory", "isCorrect": true },
          { "text": "Min replicas", "isCorrect": false }
        ]
      },
      {
        "question": "In a Kubernetes environment with multiple applications, each with different scaling needs, what is the recommended approach for HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Create a single HPA for all applications", "isCorrect": false },
          { "text": "Create a separate HPA for each application", "isCorrect": true },
          { "text": "Use a single global scaling policy for all applications", "isCorrect": false },
          { "text": "Manually adjust replicas based on traffic patterns", "isCorrect": false }
        ]
      },
      {
        "question": "What impact does setting a lower `periodSeconds` value have on HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Increases the accuracy of scaling decisions", "isCorrect": true },
          { "text": "Reduces the frequency of scale changes", "isCorrect": false },
          { "text": "Delays the response to load changes", "isCorrect": false },
          { "text": "Improves overall system performance", "isCorrect": false }
        ]
      },
      {
        "question": "You have a stateful application with varying resource requirements. How can you optimize HorizontalPodAutoscaler for such scenarios?",
        "answers": [
          { "text": "Use a fixed number of replicas", "isCorrect": false },
          { "text": "Dynamically adjust `targetAverageValue` based on resource changes", "isCorrect": true },
          { "text": "Set a constant cooldown period", "isCorrect": false },
          { "text": "Ignore resource fluctuations and scale based on requests per second", "isCorrect": false }
        ]
      },
      {
        "question": "When using custom metrics in HorizontalPodAutoscaler, what is the significance of the `metricName` parameter?",
        "answers": [
          { "text": "Specifies the metric value", "isCorrect": false },
          { "text": "Defines the metric's unit of measurement", "isCorrect": false },
          { "text": "Identifies the custom metric to scale on", "isCorrect": true },
          { "text": "Sets the target value for the custom metric", "isCorrect": false }
        ]
      },
      {
        "question": "In a scenario where your application has a sudden spike in requests per second (RPS), how does HorizontalPodAutoscaler respond?",
        "answers": [
          { "text": "Scales out immediately", "isCorrect": false },
          { "text": "Applies the cooldown period before scaling out", "isCorrect": false },
          { "text": "Scales out rapidly to handle the increased load", "isCorrect": true },
          { "text": "Ignores the spike and maintains the current replica count", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application experiences bursts of traffic during specific events. What is the most appropriate metric for HorizontalPodAutoscaler to scale based on these bursts?",
        "answers": [
          { "text": "Average CPU utilization", "isCorrect": false },
          { "text": "Memory consumption", "isCorrect": false },
          { "text": "Requests per second (RPS)", "isCorrect": true },
          { "text": "Network latency", "isCorrect": false }
        ]
      },
      {
        "question": "In a Kubernetes cluster with multiple namespaces, how can you ensure that HorizontalPodAutoscaler scales based on the metrics of a specific namespace?",
        "answers": [
          { "text": "Create a global HPA for all namespaces", "isCorrect": false },
          { "text": "Specify namespace in the HPA manifest", "isCorrect": true },
          { "text": "Scale based on the overall cluster metrics", "isCorrect": false },
          { "text": "Manually adjust replicas based on namespace traffic", "isCorrect": false }
        ]
      },
      {
        "question": "When using custom metrics in HorizontalPodAutoscaler, what is the purpose of the `targetValue` parameter?",
        "answers": [
          { "text": "Specifies the metric value", "isCorrect": false },
          { "text": "Sets the target value for the custom metric", "isCorrect": true },
          { "text": "Defines the metric's unit of measurement", "isCorrect": false },
          { "text": "Identifies the custom metric to scale on", "isCorrect": false }
        ]
      },
      {
        "question": "In a scenario where the network bandwidth is a critical factor for your application, what adjustment should be made in the HorizontalPodAutoscaler configuration?",
        "answers": [
          { "text": "Increase target CPU utilization threshold", "isCorrect": false },
          { "text": "Adjust target memory consumption value", "isCorrect": false },
          { "text": "Scale based on network latency instead of bandwidth", "isCorrect": false },
          { "text": "Include network bandwidth as a custom metric for scaling", "isCorrect": true }
        ]
      },
      {
        "question": "How does HorizontalPodAutoscaler handle scenarios where custom metric values are sporadic and not consistently available?",
        "answers": [
          { "text": "Ignores sporadic values and scales based on other metrics", "isCorrect": false },
          { "text": "Applies a smoothing algorithm to handle sporadic values", "isCorrect": false },
          { "text": "Uses predictive scaling to compensate for sporadic values", "isCorrect": true },
          { "text": "Requires manual adjustment of custom metric thresholds", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application has multiple microservices with varying resource requirements. How can HorizontalPodAutoscaler be customized to handle this diversity?",
        "answers": [
          { "text": "Use a single HPA for all microservices", "isCorrect": false },
          { "text": "Implement predictive scaling based on the aggregate metrics", "isCorrect": false },
          { "text": "Create separate HPA for each microservice", "isCorrect": true },
          { "text": "Adjust resource requirements manually based on traffic", "isCorrect": false }
        ]
      },
      {
        "question": "When using HorizontalPodAutoscaler with custom metrics, what happens if the custom metric provider experiences temporary outages?",
        "answers": [
          { "text": "Scaling continues based on other available metrics", "isCorrect": false },
          { "text": "Pauses scaling until the custom metric provider is available", "isCorrect": false },
          { "text": "Scales based on the last available custom metric value", "isCorrect": true },
          { "text": "Resorts to static scaling until the provider is restored", "isCorrect": false }
        ]
      },
      {
        "question": "What role does the `status.replicas` field play in the HorizontalPodAutoscaler status?",
        "answers": [
          { "text": "Indicates the desired number of replicas", "isCorrect": false },
          { "text": "Specifies the minimum replicas set by the HPA", "isCorrect": false },
          { "text": "Reflects the actual number of replicas currently running", "isCorrect": true },
          { "text": "Identifies the maximum replicas allowed by the HPA", "isCorrect": false }
        ]
      },
      {
        "question": "In a Kubernetes cluster with multiple node pools having different instance types, how can you optimize HorizontalPodAutoscaler for this heterogeneous environment?",
        "answers": [
          { "text": "Create a single HPA for all node pools", "isCorrect": false },
          { "text": "Adjust `targetAverageValue` based on the most powerful node pool", "isCorrect": false },
          { "text": "Use predictive scaling to adapt to varying node pool capacities", "isCorrect": true },
          { "text": "Manually adjust replicas based on node pool performance", "isCorrect": false }
        ]
      },
      {
        "question": "What happens when the `status.currentReplicas` value in HorizontalPodAutoscaler is equal to the `status.desiredReplicas` value?",
        "answers": [
          { "text": "Indicates an issue with the HPA configuration", "isCorrect": false },
          { "text": "Suggests overprovisioning of replicas", "isCorrect": false },
          { "text": "Reflects that the actual replicas match the desired replicas", "isCorrect": true },
          { "text": "Implies underprovisioning of replicas", "isCorrect": false }
        ]
      },
      {
        "question": "When utilizing HorizontalPodAutoscaler with custom metrics, what action should be taken to ensure optimal performance?",
        "answers": [
          { "text": "Frequently adjust custom metric thresholds", "isCorrect": false },
          { "text": "Periodically review and update the HPA configuration", "isCorrect": true },
          { "text": "Ignore custom metrics and rely on default metrics", "isCorrect": false },
          { "text": "Use static scaling for stability", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application has a burst of traffic every hour for a short duration. How can you optimize HorizontalPodAutoscaler for this periodic load?",
        "answers": [
          { "text": "Use predictive scaling based on historical data", "isCorrect": true },
          { "text": "Manually adjust replicas every hour", "isCorrect": false },
          { "text": "Implement cooldown period to smooth scaling", "isCorrect": false },
          { "text": "Ignore periodic load and use static scaling", "isCorrect": false }
        ]
      },
      {
        "question": "What role does the `status.lastScaleTime` field in HorizontalPodAutoscaler play?",
        "answers": [
          { "text": "Indicates the last modification time of HPA configuration", "isCorrect": false },
          { "text": "Represents the last time the HPA triggered scaling", "isCorrect": true },
          { "text": "Specifies the time of the last replicas adjustment", "isCorrect": false },
          { "text": "Reflects the last time custom metrics were updated", "isCorrect": false }
        ]
      },
      {
        "question": "When using HorizontalPodAutoscaler with a custom metric representing user engagement, what could be a potential challenge?",
        "answers": [
          { "text": "Difficulty in defining the custom metric unit", "isCorrect": false },
          { "text": "Mismatch between the custom metric and actual user engagement", "isCorrect": true },
          { "text": "Inability to scale based on user engagement", "isCorrect": false },
          { "text": "The need for frequent adjustments to the custom metric", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes cluster experiences significant fluctuations in resource availability due to external factors. How can you enhance HorizontalPodAutoscaler to adapt to this variability?",
        "answers": [
          { "text": "Implement static scaling for stability", "isCorrect": false },
          { "text": "Adjust `targetAverageValue` based on average resource availability", "isCorrect": false },
          { "text": "Use predictive scaling to anticipate resource changes", "isCorrect": true },
          { "text": "Ignore external factors and scale based on internal metrics", "isCorrect": false }
        ]
      },
      {
        "question": "In a scenario where the CPU utilization of your application is consistently low, what action should be taken to improve HorizontalPodAutoscaler responsiveness?",
        "answers": [
          { "text": "Decrease the target CPU utilization threshold", "isCorrect": false },
          { "text": "Increase the target CPU utilization threshold", "isCorrect": false },
          { "text": "Implement predictive scaling based on other metrics", "isCorrect": true },
          { "text": "Disable HorizontalPodAutoscaler for CPU metrics", "isCorrect": false }
        ]
      },
      {
        "question": "What is the role of the `status.conditions` field in the HorizontalPodAutoscaler status?",
        "answers": [
          { "text": "Specifies the desired scaling conditions", "isCorrect": false },
          { "text": "Identifies the current status of HPA conditions", "isCorrect": true },
          { "text": "Reflects the overall health of the cluster", "isCorrect": false },
          { "text": "Indicates the last time conditions were checked", "isCorrect": false }
        ]
      },
      {
        "question": "When considering predictive scaling in HorizontalPodAutoscaler, what factors should be analyzed to make accurate predictions?",
        "answers": [
          { "text": "Historical data, trends, and traffic patterns", "isCorrect": true },
          { "text": "Real-time CPU and memory utilization", "isCorrect": false },
          { "text": "Total number of pods currently running", "isCorrect": false },
          { "text": "Theoretical capacity of the Kubernetes cluster", "isCorrect": false }
        ]
      },
      {
        "question": "Your application's primary metric for performance is response time. How can you configure HorizontalPodAutoscaler to prioritize this metric?",
        "answers": [
          { "text": "Set target CPU utilization threshold to response time", "isCorrect": false },
          { "text": "Adjust `targetAverageValue` based on response time", "isCorrect": false },
          { "text": "Use a custom metric representing response time", "isCorrect": true },
          { "text": "Ignore response time and focus on CPU and memory metrics", "isCorrect": false }
        ]
      },
      {
        "question": "What is the recommended approach for scaling a stateful application with HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Use static scaling for stability", "isCorrect": false },
          { "text": "Dynamically adjust `targetAverageValue` based on stateful data changes", "isCorrect": true },
          { "text": "Manually adjust replicas based on stateful data fluctuations", "isCorrect": false },
          { "text": "Ignore stateful data and scale based on generic metrics", "isCorrect": false }
        ]
      },
      {
        "question": "When HorizontalPodAutoscaler scales in due to reduced load, what happens to the excess replicas?",
        "answers": [
          { "text": "They are immediately terminated", "isCorrect": false },
          { "text": "They go into a termination cooldown period", "isCorrect": true },
          { "text": "They continue running until manually stopped", "isCorrect": false },
          { "text": "They are automatically redistributed to other nodes", "isCorrect": false }
        ]
      },
      {
        "question": "What impact does setting a lower `updatePeriodSeconds` value have on HorizontalPodAutoscaler with custom metrics?",
        "answers": [
          { "text": "Increases the accuracy of scaling decisions", "isCorrect": false },
          { "text": "Reduces the frequency of scale changes", "isCorrect": true },
          { "text": "Delays the response to load changes", "isCorrect": false },
          { "text": "Improves overall system performance", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application has a sudden drop in user activity. How can you prevent HorizontalPodAutoscaler from scaling in too aggressively?",
        "answers": [
          { "text": "Increase the target utilization threshold", "isCorrect": false },
          { "text": "Implement a longer cooldown period", "isCorrect": false },
          { "text": "Adjust the scale-in sensitivity parameter", "isCorrect": true },
          { "text": "Manually adjust replicas to prevent scale-in", "isCorrect": false }
        ]
      },
      {
        "question": "When using HorizontalPodAutoscaler with custom metrics, what is the significance of the `labels` parameter in the metric specification?",
        "answers": [
          { "text": "Specifies the metric value", "isCorrect": false },
          { "text": "Identifies the custom metric to scale on", "isCorrect": false },
          { "text": "Filters pods based on labels for metric calculation", "isCorrect": true },
          { "text": "Defines the metric's unit of measurement", "isCorrect": false }
        ]
      },
      {
        "question": "Your application has variable memory requirements during different phases of its lifecycle. How can you configure HorizontalPodAutoscaler to handle these fluctuations?",
        "answers": [
          { "text": "Use a fixed number of replicas", "isCorrect": false },
          { "text": "Implement a dynamic `targetAverageValue` based on lifecycle phases", "isCorrect": true },
          { "text": "Adjust `targetAverageValue` based on CPU utilization", "isCorrect": false },
          { "text": "Ignore memory fluctuations and scale based on CPU only", "isCorrect": false }
        ]
      },
      {
        "question": "In a Kubernetes cluster with nodes of varying capacity, how can you optimize HorizontalPodAutoscaler for these differences?",
        "answers": [
          { "text": "Create a global scaling policy for all nodes", "isCorrect": false },
          { "text": "Use predictive scaling to adapt to node capacity", "isCorrect": true },
          { "text": "Manually adjust replicas based on node capacity", "isCorrect": false },
          { "text": "Ignore node capacity and scale based on pod metrics", "isCorrect": false }
        ]
      },
      {
        "question": "When scaling out with HorizontalPodAutoscaler, how does the algorithm determine the number of additional replicas needed?",
        "answers": [
          { "text": "Based on the average utilization of all pods", "isCorrect": false },
          { "text": "By comparing current replicas with desired replicas", "isCorrect": false },
          { "text": "Using predictive scaling based on historical data", "isCorrect": true },
          { "text": "Manually specified in the HPA configuration", "isCorrect": false }
        ]
      },
      {
        "question": "Your Kubernetes application has a specific peak time each day. What strategy can you employ with HorizontalPodAutoscaler to efficiently handle this daily load variation?",
        "answers": [
          { "text": "Use predictive scaling based on historical data", "isCorrect": false },
          { "text": "Implement a fixed schedule for scaling at peak times", "isCorrect": true },
          { "text": "Manually adjust replicas daily at peak times", "isCorrect": false },
          { "text": "Scale based on average CPU and memory utilization", "isCorrect": false }
        ]
      },
      {
        "question": "What is the role of the `scaleStatus.replicas` field in the HorizontalPodAutoscaler status?",
        "answers": [
          { "text": "Indicates the desired number of replicas", "isCorrect": false },
          { "text": "Specifies the minimum replicas set by the HPA", "isCorrect": false },
          { "text": "Reflects the actual number of replicas currently running", "isCorrect": false },
          { "text": "Identifies the replicas target set by the HPA", "isCorrect": true }
        ]
      },
      {
        "question": "In a scenario where your Kubernetes application has a sudden increase in network traffic, what adjustment should be made in the HorizontalPodAutoscaler configuration?",
        "answers": [
          { "text": "Increase target CPU utilization threshold", "isCorrect": false },
          { "text": "Adjust target memory consumption value", "isCorrect": false },
          { "text": "Scale based on network latency instead of bandwidth", "isCorrect": false },
          { "text": "Include network bandwidth as a custom metric for scaling", "isCorrect": true }
        ]
      },
      {
        "question": "When utilizing HorizontalPodAutoscaler with custom metrics, what is the recommended approach for handling metric changes or updates?",
        "answers": [
          { "text": "Pause scaling until metric changes are applied", "isCorrect": false },
          { "text": "Manually adjust custom metric thresholds", "isCorrect": false },
          { "text": "Use the last known metric value until changes are applied", "isCorrect": true },
          { "text": "Switch to default metrics until custom metrics are updated", "isCorrect": false }
        ]
      },
      {
        "question": "What is the impact of having a short `stabilizationWindowSeconds` in the HorizontalPodAutoscaler configuration?",
        "answers": [
          { "text": "Increases responsiveness to load changes", "isCorrect": false },
          { "text": "Reduces the time between scale-in and scale-out events", "isCorrect": false },
          { "text": "Requires longer cooldown periods", "isCorrect": false },
          { "text": "Introduces stability by ignoring short-term load fluctuations", "isCorrect": true }
        ]
      },
      {
        "question": "Your Kubernetes application has a sudden increase in traffic due to a marketing campaign. How can you optimize HorizontalPodAutoscaler to handle this short-term load spike?",
        "answers": [
          { "text": "Use predictive scaling based on historical data", "isCorrect": false },
          { "text": "Manually adjust replicas during the campaign", "isCorrect": false },
          { "text": "Implement a shorter cooldown period", "isCorrect": false },
          { "text": "Adjust the `targetAverageValue` to reflect campaign traffic", "isCorrect": true }
        ]
      },
      {
        "question": "When using HorizontalPodAutoscaler with custom metrics, what role does the `prometheus` provider play?",
        "answers": [
          { "text": "Specifies the metric value", "isCorrect": false },
          { "text": "Identifies the custom metric to scale on", "isCorrect": false },
          { "text": "Filters pods based on labels for metric calculation", "isCorrect": false },
          { "text": "Enables scraping of Prometheus metrics for scaling decisions", "isCorrect": true }
        ]
      },
      {
        "question": "Your Kubernetes cluster has applications with different scaling requirements. How can you efficiently manage HorizontalPodAutoscaler for these diverse applications?",
        "answers": [
          { "text": "Create a single HPA for all applications", "isCorrect": false },
          { "text": "Use predictive scaling based on aggregate metrics", "isCorrect": false },
          { "text": "Create separate HPA for each application", "isCorrect": true },
          { "text": "Manually adjust replicas based on application traffic", "isCorrect": false }
        ]
      },
      {
        "question": "In a scenario where your Kubernetes application's CPU usage is consistently high, how should you adjust HorizontalPodAutoscaler for optimal performance?",
        "answers": [
          { "text": "Increase target CPU utilization threshold", "isCorrect": true },
          { "text": "Decrease target CPU utilization threshold", "isCorrect": false },
          { "text": "Implement predictive scaling based on memory usage", "isCorrect": false },
          { "text": "Ignore CPU metrics and focus on memory utilization", "isCorrect": false }
        ]
      },
      {
        "question": "What is the purpose of the `status.lastTransitionTime` field in the HorizontalPodAutoscaler status?",
        "answers": [
          { "text": "Indicates the last time replicas were adjusted", "isCorrect": false },
          { "text": "Reflects the last update time of the HPA configuration", "isCorrect": false },
          { "text": "Specifies the time of the last scaling event", "isCorrect": true },
          { "text": "Identifies the last time custom metrics were updated", "isCorrect": false }
        ]
      },
      {
        "question": "When using HorizontalPodAutoscaler with custom metrics, what should be considered when defining the `targetAverageValue`?",
        "answers": [
          { "text": "A static value representing the metric target", "isCorrect": false },
          { "text": "The average metric value across all pods", "isCorrect": true },
          { "text": "The maximum metric value in the current cluster", "isCorrect": false },
          { "text": "The minimum metric value in the current cluster", "isCorrect": false }
        ]
      },
      {
        "question": "In a Kubernetes environment with multiple node pools of different sizes, how can you configure HorizontalPodAutoscaler to adapt to node pool variations?",
        "answers": [
          { "text": "Create a single HPA for all node pools", "isCorrect": false },
          { "text": "Adjust `targetAverageValue` based on the smallest node pool", "isCorrect": false },
          { "text": "Use predictive scaling to adapt to varying node pool capacities", "isCorrect": true },
          { "text": "Manually adjust replicas based on node pool performance", "isCorrect": false }
        ]
      },
      {
        "question": "What is the recommended approach for scaling a stateful application with HorizontalPodAutoscaler?",
        "answers": [
          { "text": "Use static scaling for stability", "isCorrect": false },
          { "text": "Dynamically adjust `targetAverageValue` based on stateful data changes", "isCorrect": true },
          { "text": "Manually adjust replicas based on stateful data fluctuations", "isCorrect": false },
          { "text": "Ignore stateful data and scale based on generic metrics", "isCorrect": false }
        ]
      },
      {
        "question": "When HorizontalPodAutoscaler scales in due to reduced load, what happens to the excess replicas?",
        "answers": [
          { "text": "They are immediately terminated", "isCorrect": false },
          { "text": "They go into a termination cooldown period", "isCorrect": true },
          { "text": "They continue running until manually stopped", "isCorrect": false },
          { "text": "They are automatically redistributed to other nodes", "isCorrect": false }
        ]
      },
      {
        "question": "How does HorizontalPodAutoscaler handle scenarios where custom metric values are sporadic and not consistently available?",
        "answers": [
          { "text": "Ignores sporadic values and scales based on other metrics", "isCorrect": false },
          { "text": "Applies a smoothing algorithm to handle sporadic values", "isCorrect": false },
          { "text": "Uses predictive scaling to compensate for sporadic values", "isCorrect": true },
          { "text": "Requires manual adjustment of custom metric thresholds", "isCorrect": false }
        ]
      }
  ]
  