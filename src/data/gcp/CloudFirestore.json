[
    {
        "question": "What is Google Cloud Firestore?",
        "answers": [
            { "text": "A cloud-based file storage service", "isCorrect": false },
            { "text": "A NoSQL document database", "isCorrect": true },
            { "text": "A cloud-based virtual machine service", "isCorrect": false },
            { "text": "A cloud networking service", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore store data?",
        "answers": [
            { "text": "In tables", "isCorrect": false },
            { "text": "In rows and columns", "isCorrect": false },
            { "text": "In documents and collections", "isCorrect": true },
            { "text": "In JSON files", "isCorrect": false }
        ]
    },
    {
        "question": "What is a document in Cloud Firestore?",
        "answers": [
            { "text": "A collection of fields", "isCorrect": true },
            { "text": "A table", "isCorrect": false },
            { "text": "A row", "isCorrect": false },
            { "text": "A file", "isCorrect": false }
        ]
    },
    {
        "question": "How are documents identified in Cloud Firestore?",
        "answers": [
            { "text": "By a numeric ID", "isCorrect": false },
            { "text": "By a combination of collection ID and document ID", "isCorrect": true },
            { "text": "By a string ID", "isCorrect": false },
            { "text": "By an automatically generated UUID", "isCorrect": false }
        ]
    },
    {
        "question": "What is a collection in Cloud Firestore?",
        "answers": [
            { "text": "A group of related tables", "isCorrect": false },
            { "text": "A group of related documents", "isCorrect": true },
            { "text": "A set of rows", "isCorrect": false },
            { "text": "A set of files", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore provide real-time updates to data?",
        "answers": [
            { "text": "Through periodic batch jobs", "isCorrect": false },
            { "text": "Through WebSocket connections", "isCorrect": true },
            { "text": "Through HTTP polling", "isCorrect": false },
            { "text": "Through RESTful API calls", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of the Firestore security rules?",
        "answers": [
            { "text": "To define the appearance of documents", "isCorrect": false },
            { "text": "To specify the database schema", "isCorrect": false },
            { "text": "To control access to documents and collections", "isCorrect": true },
            { "text": "To define document relationships", "isCorrect": false }
        ]
    },
    {
        "question": "How can you structure data in Cloud Firestore for optimal queries?",
        "answers": [
            { "text": "By using only one collection", "isCorrect": false },
            { "text": "By creating deeply nested documents", "isCorrect": false },
            { "text": "By flattening data and using multiple collections", "isCorrect": true },
            { "text": "By using only arrays for all data", "isCorrect": false }
        ]
    },
    {
        "question": "Which data types are supported by Cloud Firestore?",
        "answers": [
            { "text": "Only strings and numbers", "isCorrect": false },
            { "text": "Strings, numbers, and arrays", "isCorrect": true },
            { "text": "Strings, numbers, and booleans", "isCorrect": false },
            { "text": "Strings, numbers, booleans, and objects", "isCorrect": false }
        ]
    },
    {
        "question": "What is a transaction in Cloud Firestore?",
        "answers": [
            { "text": "A way to query data", "isCorrect": false },
            { "text": "A batch operation for inserting multiple documents", "isCorrect": false },
            { "text": "An atomic operation that reads and writes to the database", "isCorrect": true },
            { "text": "A way to perform background tasks", "isCorrect": false }
        ]
    },
    {
        "question": "How can you order query results in Cloud Firestore?",
        "answers": [
            { "text": "Only in ascending order", "isCorrect": false },
            { "text": "Only in descending order", "isCorrect": false },
            { "text": "By a single field, either ascending or descending", "isCorrect": true },
            { "text": "By multiple fields simultaneously", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of indexing in Cloud Firestore?",
        "answers": [
            { "text": "To create backups of the database", "isCorrect": false },
            { "text": "To speed up query performance", "isCorrect": true },
            { "text": "To enforce data types", "isCorrect": false },
            { "text": "To define relationships between collections", "isCorrect": false }
        ]
    },
    {
        "question": "What is the maximum number of fields allowed in a Cloud Firestore document?",
        "answers": [
            { "text": "10 fields", "isCorrect": false },
            { "text": "50 fields", "isCorrect": false },
            { "text": "100 fields", "isCorrect": false },
            { "text": "There is no strict limit", "isCorrect": true }
        ]
    },
    {
        "question": "How does Cloud Firestore handle offline data?",
        "answers": [
            { "text": "It does not support offline data", "isCorrect": false },
            { "text": "It automatically caches data for offline use", "isCorrect": true },
            { "text": "It requires manual configuration for offline mode", "isCorrect": false },
            { "text": "It stores offline data in a separate database", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's subcollections?",
        "answers": [
            { "text": "To store large binary data", "isCorrect": false },
            { "text": "To create nested documents within a document", "isCorrect": true },
            { "text": "To organize documents by type", "isCorrect": false },
            { "text": "To implement data versioning", "isCorrect": false }
        ]
    },
    {
        "question": "What is the role of the Firebase SDK in Cloud Firestore?",
        "answers": [
            { "text": "To create and manage Firestore instances", "isCorrect": false },
            { "text": "To provide authentication services", "isCorrect": false },
            { "text": "To interact with Firestore from client applications", "isCorrect": true },
            { "text": "To define security rules for Firestore", "isCorrect": false }
        ]
    },
    {
        "question": "How can you deploy Cloud Firestore security rules?",
        "answers": [
            { "text": "Through the Google Cloud Console", "isCorrect": false },
            { "text": "By using the Firestore API", "isCorrect": false },
            { "text": "Using the Firebase CLI", "isCorrect": true },
            { "text": "By making direct API calls", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's role-based access control?",
        "answers": [
            { "text": "To control the size of documents", "isCorrect": false },
            { "text": "To manage Firestore billing", "isCorrect": false },
            { "text": "To restrict access based on user roles", "isCorrect": true },
            { "text": "To define relationships between documents", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore handle data consistency?",
        "answers": [
            { "text": "By using a strict two-phase commit protocol", "isCorrect": false },
            { "text": "By ensuring strong consistency across all reads", "isCorrect": false },
            { "text": "By providing eventual consistency", "isCorrect": true },
            { "text": "By relying on external consistency services", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's snapshot listeners?",
        "answers": [
            { "text": "To take snapshots of the entire database", "isCorrect": false },
            { "text": "To listen for changes in specific documents or queries", "isCorrect": true },
            { "text": "To capture data at a specific point in time", "isCorrect": false },
            { "text": "To create backups of the database", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore handle data sharding?",
        "answers": [
            { "text": "By automatically sharding data based on collection size", "isCorrect": false },
            { "text": "By manually specifying sharding keys", "isCorrect": true },
            { "text": "By distributing data evenly across nodes", "isCorrect": false },
            { "text": "By using a central sharding service", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's geospatial querying?",
        "answers": [
            { "text": "To perform queries based on document creation time", "isCorrect": false },
            { "text": "To query documents based on their geographic location", "isCorrect": true },
            { "text": "To filter documents based on their size", "isCorrect": false },
            { "text": "To implement complex joins between collections", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore handle large data sets?",
        "answers": [
            { "text": "By limiting the total size of a collection", "isCorrect": false },
            { "text": "By automatically partitioning large collections", "isCorrect": false },
            { "text": "By using pagination to retrieve data in smaller chunks", "isCorrect": true },
            { "text": "By compressing data to reduce storage costs", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of the Cloud Firestore emulator?",
        "answers": [
            { "text": "To simulate network failures", "isCorrect": false },
            { "text": "To test Firestore security rules locally", "isCorrect": true },
            { "text": "To create a backup of the Firestore database", "isCorrect": false },
            { "text": "To optimize Firestore query performance", "isCorrect": false }
        ]
    },
    {
        "question": "How can you implement access control for Cloud Firestore on a client application?",
        "answers": [
            { "text": "By embedding access control logic in the client code", "isCorrect": true },
            { "text": "By relying solely on Firestore security rules", "isCorrect": false },
            { "text": "By using API keys for authentication", "isCorrect": false },
            { "text": "By implementing access control only on the server side", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's export and import functionality?",
        "answers": [
            { "text": "To migrate data between Firestore instances", "isCorrect": true },
            { "text": "To perform database backups", "isCorrect": false },
            { "text": "To synchronize data with external databases", "isCorrect": false },
            { "text": "To import data from CSV files", "isCorrect": false }
        ]
    },
    {
        "question": "What is the role of the Cloud Firestore REST API?",
        "answers": [
            { "text": "To provide programmatic access to Firestore security rules", "isCorrect": false },
            { "text": "To interact with Firestore from non-JavaScript applications", "isCorrect": true },
            { "text": "To create and manage Firestore instances", "isCorrect": false },
            { "text": "To define access control for Firestore", "isCorrect": false }
        ]
    },
    {
        "question": "How can you monitor and troubleshoot performance issues in Cloud Firestore?",
        "answers": [
            { "text": "By using the Cloud Firestore profiler", "isCorrect": false },
            { "text": "Through the Google Cloud Console", "isCorrect": true },
            { "text": "By analyzing Firestore security rule violations", "isCorrect": false },
            { "text": "By relying on client-side error logs", "isCorrect": false }
        ]
    },
    {
        "question": "What is the purpose of Cloud Firestore's multi-region support?",
        "answers": [
            { "text": "To increase the maximum document size", "isCorrect": false },
            { "text": "To replicate data across multiple geographic locations", "isCorrect": true },
            { "text": "To implement cross-region joins between collections", "isCorrect": false },
            { "text": "To enable global transactions in Firestore", "isCorrect": false }
        ]
    },
    {
        "question": "How does Cloud Firestore handle data migration and schema changes?",
        "answers": [
            { "text": "By automatically migrating data on-the-fly", "isCorrect": false },
            { "text": "By requiring manual schema changes for every update", "isCorrect": false },
            { "text": "By providing tools for controlled schema changes", "isCorrect": true },
            { "text": "By preventing schema changes once data is stored", "isCorrect": false }
        ]
    }, 
    {
        "question": "Scenario: You are developing a mobile app that requires real-time updates to user profiles. How would you structure your data in Cloud Firestore to achieve this?",
        "answers": [
            { "text": "Create a single document for each user with all profile information.", "isCorrect": false },
            { "text": "Use a separate collection for user profiles and update documents in real-time with Firestore snapshot listeners.", "isCorrect": true },
            { "text": "Store user profiles as nested documents within a 'profiles' collection.", "isCorrect": false },
            { "text": "Use Cloud Functions to push updates to user profiles at regular intervals.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application needs to display a list of products with prices, and you want to allow users to filter products based on price ranges. How would you model the data in Cloud Firestore to optimize querying?",
        "answers": [
            { "text": "Use a single collection for all products and perform client-side filtering based on price ranges.", "isCorrect": false },
            { "text": "Create a 'products' collection and use subcollections for different price ranges.", "isCorrect": false },
            { "text": "Flatten the data by storing products in a 'products' collection and add an array field for price ranges.", "isCorrect": true },
            { "text": "Create a separate collection for each price range and store products within those collections.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: You want to implement role-based access control in your application using Cloud Firestore. How would you achieve this?",
        "answers": [
            { "text": "Embed access control logic in the client application and rely on Firestore security rules for an additional layer of security.", "isCorrect": true },
            { "text": "Use Firebase Authentication roles to manage access control without involving Firestore security rules.", "isCorrect": false },
            { "text": "Create separate Firestore instances for each user role and manage access control at the database level.", "isCorrect": false },
            { "text": "Implement access control only on the server side, ignoring client-side access control logic.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application requires offline support, and you need to ensure that data is synchronized seamlessly when the device comes online. How would you handle offline data in Cloud Firestore?",
        "answers": [
            { "text": "Manually trigger synchronization when the device reconnects to the internet.", "isCorrect": false },
            { "text": "Automatically cache data for offline use, and sync changes when the device is online.", "isCorrect": true },
            { "text": "Implement a separate local database to store offline data and sync it with Cloud Firestore periodically.", "isCorrect": false },
            { "text": "Use Cloud Functions to handle offline synchronization by listening for device connectivity events.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application involves geospatial data, and you need to query documents based on their geographic location. How would you structure your data in Cloud Firestore to support geospatial queries?",
        "answers": [
            { "text": "Store latitude and longitude as separate fields in each document and query based on these fields.", "isCorrect": true },
            { "text": "Create a separate collection for each geographic location and store documents within those collections.", "isCorrect": false },
            { "text": "Use a single collection for all documents and implement a custom geospatial index.", "isCorrect": false },
            { "text": "Embed geospatial data as nested documents within each main document.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: You are developing a blogging platform where users can create posts and comment on them. How would you structure your Firestore data to efficiently retrieve post comments and maintain a good user experience?",
        "answers": [
            { "text": "Embed comments as an array within each post document.", "isCorrect": false },
            { "text": "Create a subcollection for comments under each post document.", "isCorrect": true },
            { "text": "Use a separate collection for comments and reference them in each post document.", "isCorrect": false },
            { "text": "Store comments in a flat structure within the main 'posts' collection.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application requires user authentication, and you want to store additional user details beyond the basic authentication information. How would you link user authentication data with custom user details in Firestore?",
        "answers": [
            { "text": "Create a separate collection for user details and reference them using user authentication IDs.", "isCorrect": true },
            { "text": "Embed user details directly within the user authentication documents.", "isCorrect": false },
            { "text": "Use Firebase Authentication's custom claims to store additional user details.", "isCorrect": false },
            { "text": "Maintain a separate Firestore instance for user details and link them using cross-database queries.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application needs to support multi-region data synchronization, and you want to ensure low-latency access to data for users worldwide. How would you architect your Firestore database to achieve this?",
        "answers": [
            { "text": "Use a single Firestore instance in a central region and rely on Firestore's global distribution.", "isCorrect": true },
            { "text": "Create separate Firestore instances for each region and synchronize data across instances.", "isCorrect": false },
            { "text": "Implement a custom data synchronization solution using Cloud Functions.", "isCorrect": false },
            { "text": "Store region-specific data in separate collections and manage synchronization manually.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application involves frequent updates to documents, and you want to minimize the risk of data inconsistency. How would you handle atomic transactions in Cloud Firestore?",
        "answers": [
            { "text": "Use batched writes for multiple document updates within a transaction.", "isCorrect": false },
            { "text": "Leverage Firestore transactions to perform atomic updates to multiple documents.", "isCorrect": true },
            { "text": "Implement a custom versioning system to track changes and rollback on inconsistency.", "isCorrect": false },
            { "text": "Manually lock documents during updates to ensure atomicity.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application requires user-generated content that needs to be moderated before being displayed. How would you implement content moderation in Cloud Firestore?",
        "answers": [
            { "text": "Perform content moderation on the client side before submitting data to Firestore.", "isCorrect": false },
            { "text": "Use Firestore security rules to enforce content moderation at the database level.", "isCorrect": false },
            { "text": "Implement a Cloud Function to moderate content before it is persisted in Firestore.", "isCorrect": true },
            { "text": "Create a separate Firestore instance for moderated content and sync it with the main database.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: You are building a real-time collaborative editing tool, and multiple users can simultaneously edit a shared document. How would you structure your Firestore data to handle concurrent updates and ensure data consistency?",
        "answers": [
            { "text": "Use Firestore's optimistic concurrency control to handle simultaneous updates.", "isCorrect": false },
            { "text": "Implement a custom locking mechanism to prevent concurrent edits to the same document.", "isCorrect": false },
            { "text": "Leverage Firestore transactions to ensure atomicity and consistency during document updates.", "isCorrect": true },
            { "text": "Store each user's edits in separate documents and merge them at the client side.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application involves a hierarchical structure, and you want to efficiently query and retrieve data at different levels of the hierarchy. How would you organize your Firestore data for optimal query performance?",
        "answers": [
            { "text": "Use nested subcollections for each level of the hierarchy to simplify queries.", "isCorrect": false },
            { "text": "Flatten the hierarchy by denormalizing data and using references between documents.", "isCorrect": true },
            { "text": "Create separate Firestore instances for each level of the hierarchy for isolation.", "isCorrect": false },
            { "text": "Implement a custom indexing solution to speed up queries on hierarchical data.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application involves user-generated content with multimedia files, and you want to store and retrieve large binary objects efficiently. How would you manage storage of multimedia files in Firestore?",
        "answers": [
            { "text": "Use Firestore documents to store multimedia files directly as binary data.", "isCorrect": false },
            { "text": "Leverage Firebase Cloud Storage to store multimedia files and reference URLs in Firestore.", "isCorrect": true },
            { "text": "Split multimedia files into smaller chunks and store them as separate Firestore documents.", "isCorrect": false },
            { "text": "Encode multimedia files as Base64 strings and store them in Firestore documents.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application needs to perform complex queries involving sorting and filtering on large datasets. How would you optimize Firestore queries for better performance?",
        "answers": [
            { "text": "Use Firestore's built-in indexing for all fields involved in queries.", "isCorrect": true },
            { "text": "Manually sort and filter data on the client side to reduce query complexity.", "isCorrect": false },
            { "text": "Create separate Firestore instances for specific query patterns to isolate data.", "isCorrect": false },
            { "text": "Implement a caching layer to precompute query results and speed up subsequent requests.", "isCorrect": false }
        ]
    },
    {
        "question": "Scenario: Your application involves tracking user activities, and you want to implement real-time notifications based on changes in Firestore data. How would you design the notification system using Firestore?",
        "answers": [
            { "text": "Periodically poll Firestore for changes and send notifications based on diffs.", "isCorrect": false },
            { "text": "Use Firestore triggers to invoke Cloud Functions for real-time notifications.", "isCorrect": true },
            { "text": "Embed notification logic directly in the client application.", "isCorrect": false },
            { "text": "Implement a separate Firestore instance dedicated to storing notifications.", "isCorrect": false }
        ]
    }
]
